https://www.debian.org/doc/debian-policy/ch-binary.html#s-maintscriptprompt
---

## 3. 二进制包

Debian 发行版基于名为 `dpkg` 的 Debian 包管理系统。因此，Debian 发行版中的所有包都必须以 `.deb` 文件格式提供。

一个 `.deb` 包包含两组文件：一组是在包安装时将要安装到系统上的文件，另一组是提供关于包的额外元数据或在包安装或移除时被执行的文件。这第二组文件称为**包元数据文件**。这些文件中包括包维护脚本和 `control` 文件（包含包控制字段的二进制包控制文件）。其他包元数据文件包括用于存储共享库依赖信息的 `symbols` 或 `shlibs`，以及列出包配置文件（在 *配置文件* 中描述）的 `conffiles` 文件。

不幸的是，这里存在术语上的冲突：控制信息文件与采用 Debian 控制文件格式的文件。在本文档中，**控制文件** 指的是采用 Debian 控制文件格式的文件。这些文件在 *控制文件及其字段* 中有详细说明。只有特别称为**包元数据文件**的文件，才是二进制包使用的 `.deb` 文件格式中包元数据成员（称为 `control.tar`）所包含的文件。大多数包元数据文件并不采用 Debian 控制文件格式。

### 3.1. 包名称

每个包必须有一个在 Debian 归档库内唯一的名称。

包名称包含在控制字段 `Package` 中，其格式在 *Package* 中描述。包名称也作为 `.deb` 文件文件名的一部分包含在内。

#### 3.1.1. 包含潜在冒犯性内容的包

作为维护者，您应判断包的内容是否适合包含，是否需要任何形式的内容警告，以及是否应将某些部分拆分到单独的包中（以便希望避免某些部分的用户可以这样做）。在做出这些决定时，您应考虑我们 *多元化声明* 中表达的项目观点。

如果您将（潜在的）冒犯性或令人不安的材料拆分到单独的包中，通常应在包名称中通过添加 `-offensive` 来标记。例如，`cowsay` 与 `cowsay-offensive`。在这种情况下，核心包可以**建议** 这个 `-offensive` 包，但不应**推荐** 或**依赖** 它。

### 3.2. 包的版本

每个包都有一个记录在其 `Version` 控制文件字段中的版本号，在 *Version* 中描述。

包管理系统对版本号施加了一个排序规则，以便能够判断包是正在升级还是降级，并且包系统前端应用程序能够判断其找到的可用包是否比系统上安装的包新。版本号格式将（就比较而言）最重要的部分放在开头。

如果上游包的版本号有问题，应将其转换为合理的形式以用于 `Version` 字段。

#### 3.2.1. 基于日期的版本号

通常，Debian 包应使用与上游源代码相同的版本号。然而，基于某些日期格式的上游版本号（有时用于开发或“快照”版本）将不会被包管理软件正确排序。例如，`dpkg` 会认为 "96May01" 大于 "96Dec24"。

为了避免为每个新的上游版本使用 epoch，任何上游版本号中基于日期的部分应以能正确排序的方式给出：首先是四位数的年份，接着是两位数的数字月份，然后是两位数的数字日期，组件之间可以使用标点符号。

版本号包含日期的原生 Debian 包（即为 Debian 特别编写的包）也应遵循这些规则。如果希望在日期组件之间使用标点符号，请记住连字符 (-) 不能用于原生版本号。句点 (.) 通常是一个不错的选择。

#### 3.2.2. 版本号的唯一性

一旦包被接受进入归档库，版本号中 epoch 之后的部分不得被内容不同的包版本重用，即使先前使用该版本号部分的包版本已不存在于任何归档套件中。

此唯一性要求适用于源包和二进制包的版本号，即使生成给定二进制包的源包发生更改。因此，二进制包不得重用的版本号包括任何曾被接受进入归档库的该二进制包版本的所有版本号，无论其属于哪个源包。

此外，对于非原生包，上游版本不得被用于不同的上游源代码，因此对于每个源包名称和上游版本号，只存在一个原始源代码归档内容（参见 *文件*）。

这些限制的原因如下：Epoch 不包含在构成源包的文件名中，也不包含在二进制包的文件名中，因此重用版本号（即使 epoch 不同）会导致同名的文件具有不同的内容。这会引起各种问题。

如果您发现自己想要重用 epoch 之后的版本号部分，您可以只增加 Debian 修订号，它不必从 1 开始，也不必是连续的。

### 3.3. 包的维护者

每个包必须有一个维护者，除了下面描述的孤儿包。维护者可以是一个人，也可以通过一个共同的电子邮件地址（例如邮件列表）联系到的一组人。维护者负责维护 Debian 打包文件、评估并适当回应报告的 bug、上传包的新版本（直接或通过赞助者）、确保包被放置在适当的归档区域并根据包的稳定性和效用包含在 Debian 发行版中，以及如果包不再有用或可维护则请求将其从 Debian 发行版中移除。

维护者必须在 `Maintainer` 控制字段中指定其正确的姓名和有效的电子邮件地址。`Maintainer` 控制字段中给出的电子邮件地址必须接受来自 Debian 中用于发送有关包的自动化邮件的那些角色账户的邮件。这包括来自 bug 跟踪系统的非垃圾邮件、来自 Debian 归档维护软件的所有邮件，以及项目普遍同意的其他角色账户或自动化流程的邮件。[1] 如果一个人或团队维护多个包，他们应在这些包的 `Maintainer` 字段中使用相同形式的姓名和电子邮件地址。

`Maintainer` 控制字段的格式在 *Maintainer* 中描述。

如果包的维护者是一个拥有共享电子邮件地址的团队，则必须存在 `Uploaders` 控制字段，并且该字段必须至少包含一个带有个人电子邮件地址的人。有关该字段的语法，请参见 *Uploaders*。

**孤儿包** 是指没有当前维护者的包。孤儿包应将其 `Maintainer` 控制字段设置为 `Debian QA Group <packages@qa.debian.org>`。这些包被视为由整个 Debian 项目维护，直到有其他人自愿接管维护工作。[2]

### 3.4. 包的描述

每个 Debian 包必须有一个 `Description` 控制字段，其中包含包的概要介绍和详细描述。关于 `Description` 字段格式的技术信息在 *Description* 中。

描述应向从未接触过该包（程序）的用户（系统管理员）描述它，以便他们有足够的信息来决定是否要安装它。此描述不应仅仅逐字复制自程序的文档。

将重要信息放在前面，无论是在概要介绍还是详细描述中。有时只会显示概要介绍或描述的第一部分。您可以假设通常会有办法查看整个详细描述。

描述还应提供关于该包与其他包之间的重要依赖和冲突的信息，以便用户了解为什么声明了这些依赖和冲突。

不应包含配置或使用包的说明（这是安装脚本、手册页、info 文件等的用途）。也不应包含版权声明和其他行政信息（这是 `copyright` 文件的用途）。

#### 3.4.1. 单行概要介绍

单行概要介绍应保持简短——肯定少于 80 个字符。

不要在概要介绍行中包含包名。显示软件知道如何显示它，您无需说明。请记住，在许多情况下用户可能只看到概要介绍行——请尽可能使其信息丰富。

#### 3.4.2. 详细描述

不要试图将单行概要介绍延续到详细描述中。当显示完整描述时，这将无法正确工作，并且在只有概要介绍（单行概要介绍）可用的情况下也没有意义。

详细描述应描述包的功能以及它如何与系统的其余部分相关联（例如，就它是哪个子系统的一部分而言）。

描述字段需要对任何人都有意义，即使是对包所处理的任何事物都一无所知的人。[3]

### 3.5. 依赖关系

每个包必须指定关于其他包的依赖信息，这些信息是包正确运行所必需的。

例如，必须为包中动态链接的可执行二进制文件所需的任何共享库提供依赖项。

包不需要声明它们对标记为 `Essential` 的其他包的任何依赖关系（见下文），并且除非依赖于该包的特定版本，否则不应这样做。[4]

有时，解包一个包需要先解包和配置另一个包。在这种情况下，依赖包必须在 `Pre-Depends` 控制字段中指定此依赖关系。

您不应在 `debian-devel` 邮件列表上讨论并达成共识之前，为包指定 `Pre-Depends` 条目。

包相互关系控制字段的格式在 *声明包之间的关系* 中描述。

### 3.6. 虚拟包

有时，有几个包提供或多或少相同的功能。在这种情况下，定义一个虚拟包是很有用的，其名称描述了该通用功能。（虚拟包仅在逻辑上存在，而不是物理上存在；这就是为什么它们被称为虚拟包。）具有此特定功能的包将**提供** 该虚拟包。因此，任何需要该功能的其他包可以简单地依赖该虚拟包，而不必单独指定所有可能的包。

所有包在适当的情况下都应使用虚拟包名称，并在必要时创建新的虚拟包。除非虚拟包名称已被同意并出现在虚拟包名称列表中，否则不应使用它们（除非在合作包组内部私下使用）。（另请参阅 *虚拟包 - Provides*）

虚拟包名称的权威列表的最新版本可以在 `debian-policy` 包中找到。也可以从 Debian 网络镜像获取：https://www.debian.org/doc/packaging-manuals/virtual-package-names-list.yaml。

更新列表的程序在列表的前言中有描述。

### 3.7. 基本系统

基本系统是 Debian 系统的一个最小子集，在新系统上先于其他所有内容安装。只有极少数包被允许构成基本系统的一部分，以保持所需的磁盘使用量非常小。

基本系统包括所有优先级为 `required` 或 `important` 的包。其中许多将被标记为 `essential`（见下文）。

### 3.8. 基础包

`Essential` 被定义为系统在任何时候都必须可用和可用的最小功能集，即使包处于“已解包”状态。使用 `Essential` 控制字段为系统标记基础包。`Essential` 控制字段的格式在 *Essential* 中描述。

由于这些包不能被轻易移除（必须向 `dpkg` 指定一个额外的强制选项才能这样做），除非绝对必要，否则不得使用此标志。共享库包不得标记为基础包；依赖关系将防止其被过早移除，并且我们需要在它被取代时能够移除它。

由于 `dpkg` 不会在基础包处于未配置状态时阻止其他包的升级，所有基础包必须提供其所有核心功能，即使在至少配置过一次后处于未配置状态。如果包不能满足此要求，则不得将其标记为基础包，并且任何依赖于此包的包必须根据情况具有明确的依赖字段。

维护者在向基础包添加任何程序、接口或功能时应非常小心。包可能会假设基础包提供的功能始终可用而无需声明显式依赖，这意味着从基础集中移除功能非常困难，几乎从未做过。因此，添加到基础包中的任何功能都产生了一项义务，即需要永久地支持该功能作为基础集的一部分。

在 `debian-devel` 邮件列表上讨论并达成共识之前，您不得将任何包标记为基础包。

### 3.9. 维护脚本

包安装脚本应避免产生用户无需看到的输出，并应依赖 `dpkg` 来避免安装许多包的用户感到无聊。这意味着，除其他事项外，不要将 `--verbose` 选项传递给 `update-alternatives`。

必须检查安装脚本执行期间发生的错误，并且在错误发生后不得继续安装。

请注意，通常 *脚本* 中的规则也适用于包维护脚本。

您不应在未先咨询该包维护者的情况下，对属于另一个包的文件使用 `dpkg-divert`。在添加或移除转移时，包维护脚本必须向 `dpkg-divert` 提供 `--package` 标志，并且不得使用 `--local`。

所有提供通用命令名称（或广义上的文件名）实例的包通常应使用 `update-alternatives`，以便它们可以一起安装。如果不使用 `update-alternatives`，则每个包必须使用 `Conflicts` 来确保其他包被移除。（在这种情况下，针对先前未使用 `update-alternatives` 的早期版本指定冲突可能是合适的；这是通常应避免版本化冲突规则的一个例外。）

转移主要旨在作为本地管理员和本地包覆盖 Debian 行为的工具。虽然在某些情况下一个 Debian 包可能需要转移另一个 Debian 包安装的文件，但这种情况很少见。只要其他机制足以实现相同目标，维护者应强烈倾向于使用其他覆盖机制，而不是转移。换句话说，包中的转移应被视为最后的手段。一个 Debian 包转移另一个 Debian 包中的文件应在这些包的维护者之间进行协调。

此规则的一个具体案例是：由 systemd 组件使用的配置文件，例如单元、udev 规则、tmpfiles.d、modules-load.d、sysusers 以及其他此类文件，包括 systemd 守护进程特定的文件（例如：`/etc/systemd/system.conf`），不得被任何 Debian 包转移。相反，应使用屏蔽和 drop-in。

不得对 systemd 配置文件使用替代项。替代系统不知道如何在更新替代项时对服务应用更改，因此 resulting behavior would be confusing and unpredictable。相反，可以使用别名来提供同名单元的不同实现。

#### 3.9.1. 维护脚本中的提示

包维护脚本在必要时可以提示用户。提示必须通过符合 Debian 配置管理规范（版本 2 或更高）的程序（例如 `debconf`）进行通信。

基础包或基础包的依赖包，如果在执行时没有此类接口可用，可以回退到另一种提示方法。

Debian 配置管理规范包含在 `debian-policy` 包的 `debconf_specification` 文件中。也可以从 Debian 网络镜像获取：https://www.debian.org/doc/packaging-manuals/debconf_specification.html。

使用 Debian 配置管理规范的包可能包含额外的包元数据文件 `config` 和 `templates`。`config` 是一个用于包配置的额外维护脚本，`templates` 包含用于用户提示的模板。`config` 脚本可能在 `preinst` 脚本之前运行，并且在包解包或其任何依赖项或预依赖项满足之前运行。因此，它必须仅使用基础包中存在的工具工作。[5]

使用 Debian 配置管理规范的包必须允许通过使用基于 gettext 的系统（例如 `po-debconf` 包提供的系统）来翻译其用户可见的消息。

包应尽量减少需要提示的量，并应确保每个问题只问用户一次。这意味着包应尝试使用适当的共享配置文件（例如 `/etc/papersize` 和 `/etc/news/server`）和共享的 debconf 变量，而不是各自提示自己所需的信息列表。

这也意味着升级不应再次询问相同的问题，除非用户使用 `dpkg --purge` 清除了包的配置。配置问题的答案应存储在 `/etc` 中的适当位置，以便用户可以修改它们，并且应记录下是如何做到这一点的。

如果包有极其重要的信息要传递给用户（例如“不要按原样运行我，您必须先编辑以下配置文件，否则您的系统可能发出格式错误的消息的风险”），它应在 `config` 或 `postinst` 脚本中显示此信息，并提示用户按回车键确认消息。版权消息不算极其重要（它们属于 `/usr/share/doc/PACKAGE/copyright`）；如何使用程序的说明也不算（这些应放在在线文档中，所有用户都可以看到）。

任何必要的提示几乎都应仅限于 `config` 或 `postinst` 脚本。如果在 `postinst` 中进行，应使用条件语句进行保护，以便在包安装失败并使用 `abort-upgrade`、`abort-remove` 或 `abort-deconfigure` 调用 `postinst` 时，不会发生不必要的提示。

---

**脚注:**

[1] 为 Mailman 邮件列表管理软件编写的此类白名单的示例实现用于由 https://alioth-lists.debian.net/ 托管的邮件列表。

[2] 优雅地孤儿化包的详细程序可以在 *Debian Developer's Reference* 中找到（参见 *相关文档*）。

[3] 程序在其公告和/或 README 文件中附带的简介很少适合用于描述。它通常针对已经处于使用该包的社区中的人。

[4] 部分需要 `Essential` 是为了避免升级时出现无法解决的依赖循环。如果包不必要地依赖于此集合中的包，那么在需要这些基础包之前强制它们先配置而导致出现无法解决的依赖循环的可能性将大大增加。这也增加了前端无法计算升级路径的可能性，即使存在这样的路径。

此外，功能很少从基础集中移除，但当功能移动到不同的包时，包曾从基础集中移除。因此，为了防止它们停止成为基础包而依赖这些包弊远大于利。

[5] Debconf 或另一个实现 Debian 配置管理规范的工具也将被安装，并且对它的任何版本化依赖关系将在预配置开始之前得到满足。
